# Cursor AI Just Got Smarter 4 New Rule Types

Published: 2025-03-24

Over the past six weeks, since my last video on cursor rules, cursor has made some massive improvements and changes to the way their cursor rule system works to further empower you to get the cursor agent to behave the way you want it to. Unfortunately, if you go to the cursor documentation site, the documentation does not really get into a lot of these changes. And beyond cursor rules, if you remember my last video, I also shared the cursor auto rules agile workflow and specifically a rule that will help you automatically have cursor agent generate rules for you. Over the past six weeks, with almost daily changes to cursor coming and being updated, the rule itself in this repo has constantly been updated to keep it working with the latest changes in cursor. Along with feedback from the community, comments on previous YouTube channels and in the Reddit and cursor forums, I've taken a lot of your feedback and incorporated it into a new and much better version. So today I'm going to share with you the key changes in cursor, how the new auto rule generating works with these changes, and finally I'm going to show you some new kick-ass demos that I think will really get you excited about the potential with this new rule system. Let's head over to Cursor. And first, what I want to tell you about is Cursor released four new rule types. This is not in their documentation but it is mentioned throughout the ID in other places. The rule types are agent selected which means the agent sees the description without loading the rest of the rule into its context and then based on the description the agent itself will determine if it needs to load the full rule and only load the bulk of the rule when it needs it. Of course, as always, this requires you to have a very good description, which is why I mentioned that the description field is critical. So, the AI agent will clearly know and understand when it needs to load the rest of that rule. The next rule type is always, and this means it is applied to every chat, agent window, or command K request. This is closest to the way cursor used to be in the beginning where you had a root. Rules file at the root of your project or would use the AI agent window. Now there's also auto select and auto select is very similar to agent select but this is basically apply a rule whenever it conforms to a specific file type. Whereas agent selected doesn't necessarily care about the fi the file type because the glob field is kept blank. It will try to apply it to whatever it thinks is relevant. Auto select on the other hand can have the description field blank and if the agent just sees that a rule is tied to a specific file and it knows that it's working in that file such as a TS file or a BAT file or AEMV file, it will automatically select and use that rule based on just that file. And finally, we have manual. Manual is basically what I like to call macro mode. And this is super exciting. With macro or manual mode, you tell the agent when to use the rule. Now, at first that might not sound very exciting, but I found some very cool use cases for these macros. I'm going to show you examples of all of these and how to set these up. But first, I just wanted to lay out this key change. The next big change that's come from cursor is the ability to organize your rules into subfolders. So 6 weeks ago the change from cursor was all cursor rules should go in a cursor/ruules folder. And with that in my past video if you watched it or if you looked at my auto rule generator what I would do is I would prefix every rule with a number to indicate a category so I could keep the rules somewhat grouped in the folder. With the recent change from cursor, we can see here that cursor now supports subfolders for your rules. So now instead of using prefixes on files, I use folders. I do this all with the AI agent. All rule creation I do almost 100% is me asking the agent to create the rule for me. Okay, so that is the subfolders and I mentioned the four new rule types. Let me show you in cursor where these uh four rule types come from and how to work with them. I'm going to hit F1. And if you don't have this option here, you can just type cursor rule. And just like always, we're going to create a new cursor rule. Okay. Now, this is not auto rule generation. This is not automatically putting in the folders in the subfolders like I told you, but I just want to show you the UI that comes up here. So, if you ever forget what the different rule types are or how to configure them, you can use this UI to generate the rule this way. And you'll see this UI comes up when you first create the rule. And you can see that there's these rule options here. When we have always selected, you can see that the description field right here is not editable. and it indicates that this rule is attached to every chat and command K requested. If we go to autoattached, you can see that now we don't have a description field, but we do have the ability to put in glob patterns. Now, here is the agent requested one. And you'll notice here it has a description field. And then finally, we have manual, which I said I like to call this macro mode. And it specifically tells you this rule needs to be mentioned to be included. What I actually want to show you and describe is a problem with the previous auto rule generator. The agents in agent mode, you would ask it to create a rule or update a rule and it would fail to save the file. And a lot of that was because of this viewer for MDC's causing conflicts with changes. If I go away from this rule and then go back to it, you can see that I'm not looking at that viewer anymore. And this is actually preferred for me because now I can see the real magic behind the rules. If we go into the user settings. So I'll just type user and then go to preferences open user settings. And I click this button over here to view the JSON. And in the JSON, these are additional settings that you've added beyond all the defaults. So these are my preferences for fonts. Um I like format on save to be true. So, it automatically formats. Um, there's some other changes in here, but the key one that I want to point out to you is this one right here, workbench.editor associations. This is where you tell VS Code when I open a certain file type, I want to use this viewer. By setting star.mdc to default, it will now just use the normal text editor instead of using that view. By doing this, I have found that this 100% fixes the issues with the agent having conflicts creating and updating rules and failing to save the rules. This right here is a game changer for working with agent automatic rule generation. All right, let's finally get to some awesome demos, huh? So, I'm going to go into cursor here and using this rules template, I'm going to run this file apply rules.sh SH to a new project called my cool project. And what this does is this copies all the core rules, all the rules that are basically in here also the templates. So by running that we can now open up cursor in our new project which we called my cool project and I will make this much bigger. So now we're in a brand new project. And you can see this could be an existing project or a new project. It will not destructively overwrite any rules that you already have, but it will add this new core rule generator that drives everything that we're about to demo. So in a recent version of cursor, I think uh45 or 46, they did build in the ability for the cursor agent to search the web on its own, which is really cool. But what if you want to do deeper research with perplexity or tavally? Well, that requires MCP. So, if we go into cursor, I'm going to enable in the cursor settings an MCP for Tavly search. I've set this up before. So, all I need to do is enable it. But if I just ask cursor a question such as what has happened with something in the last 30 days, the agent on its own will decide whether or not it wants to use taby. But what if there are specific cases where I wanted to use that all the time? Well, that's where the power of rules come in. So let's clear all our context and we have Tavly set up here. If you go to Tavi, you can basically sign up for free. You just create an API key. They give you a,000 free credits per month, which is a lot. I've never gone through it. And they have a great page with very detailed, easy to follow instructions for how to set up the MCP client in cursor. So let's use super whisper to ask the agent to create a rule for us. create a agent rule when I request deep research that you will always use the MCP tool tavally and then you will always use the date command on the system to get the current systems date and time and inject that to all the requests to tavally when doing any type of search or research. This way you will not be thinking that timebound or time contextual research is tied to your system context in your training data but instead use the actual machine system date and time. For example, you sometimes think it's 2024, but it's actually 2025 and you screw up web results thinking that information is out of date. Now, you'll notice that I also gave it an example of why it sometimes screws up. So, I hope that into the example, it will also inject a little bit of information about using the proper date and how to use it with the searches. So, first of all, it is using an agent. It's going to create an agent rule and it found our rule generating agent. We can see that the rule it's creating is of type agent because that's what I requested and it has a rule here that it generated. So now it will give us the output and it's going to say basically that it was successful. It tells us where it put it um the rule type and it gives us a short a short summary. First of all you can see it got the front matter correct by making this always apply false and putting a very detailed description here. Let's see if the detailed description though is worded in a way that it will be picked up. When conducting deep research, use current system time and tavly search tools to ensure time relevant results. I think that should work. If we ever find out that we request deep research and is not using this, we can make it a little bit more explicit and say when the user requests specifically deep research. But I like the way this is worded because sometimes even if I don't use the words deep research and it thinks it needs deep research, it will probably still pick up this rule. Gives a little bit of context. Here's the important part which is the critical rules. Now it gives an example and a invalid example. So in the example, you can show that it's basically instructing the UI, hey, first I get today's date and then it uses that date when computing it and then it shows an anti-attern or an anti-example where it doesn't get the date. It relies on its trading data and it makes the user very unhappy. So that's all well and good. There's a rule there, but it's only useful if the rule actually works, right? So let's fully clear our context so we're not cheating and using the rule in the context. So now we have a brand new window here. do deep research on changes within the last 30 days to Klein and also cursor UI and then give me a one paragraph summary result highlighting the key changes to each product and which is the best to use right now for my needs as a software developer. All right. So again, we're asking for deep research uh for client and cursor. And again, we can see it did find a rule called research time context agent. And this is applied to deep research. We can see it did check the system date right there. Awesome. And now it is calling Cavali search multiple times, combining the results, and continuing to refine the results to do more searches as it needs to to answer the actual question that we answered. That's why I love Tavi or Perplexity for deep research. And then it formatted the results exactly like I asked for. You can we can see it also used March 23rd. And so it looked for updates that came within the last 30 days and it seemed to figure that out. That is using an agent rule. Now let's go to an example. Here's a rule I called get push. And this is an example of what I called a manual or a macro. basically no description, no globs, always apply false. And if you're using that UI, that is manual. Now, why would I do that? Well, specifically to use a manual rule, you just call the file name. So, we've made some changes here. This is not actually a git repo, but if it were, what I can do is in agent mode, I can just say at get push, excuse me, if I can type it. And I will select the one that says tool rules get push. Now I can just hit enter. And what I have for this rule as a macro is it looks at all the changes that have not been staged or pushed. It will use the AI to produce a initial commit message and then it will push it to the initial working branch. The funny thing is this just realized that this was not a git repo. So it is now creating a git repo. It's adding everything. So this is great. There won't be any remote to push it to but it is now going to figure out what the changes are. So this sees every file is a brand new file. So this is probably going to give us a very interesting summary of what we're doing. Let's see what the get message looks like. Um, set up an initial project structure with cursor auto rules, agile workflow templates, and configuration. This also includes rule templates for core operations, documentation, global behavior guidelines, yada yada yada. Agent committed uh agent generated commit message. Please like this video if you found this at all helpful. Share it in the forums or on Reddit and uh subscribe to the channel because I have a lot of cool content coming out. We've talked a lot about cursor rules and I highly suggest that you use this automated way of creating rules and create rules when you need them. You can go on the internet and you can find websites with repositories with hundreds or thousands of pre-baked rules for every project type. And let me tell you, you do not need these in most cases, especially if you're developing a new project that's green field and a well-known framework that's pretty popular and has a lot of, you know, traction on GitHub. The LLM models are getting better and better and have been trained on so many of these projects that they don't need lots of rules to understand how these frameworks and libraries and languages work and what the best practices are. rely on the LLM. See what it can do at first and then give it guard rails as you need to. Which goes on to the next tip. Use the agent in a self-correcting fashion. So when you notice the agent does something wrong, do what I did. Tell the agent, "Hey, you did this. It caused this issue. Don't do it again. Create a rule instead so that you don't do XYZ in the future and instead you do ABC." If you ever notice that a rule is still not properly being picked up, go in there and check the description if it's an agent rule and further refine the description tag to make it very clear when the agent will pick it up. The agent rules work by collecting all of your rules, agent descriptions that gets fed into every agent context, but it's just one sentence from all of your rules. So it's not a lot of context overhead. What cursor does is cursor looks at all of those. It looks at what you just asked it to do or what's going on in the thread and it determines which of those it needs to then look at and pull in the rest of the information into its context. So it's keeping the overall context low by just pulling in what it does. So if that description is not explicit enough for it to know when to guess at taking that information in, it's not going to do it. It's optimized for not pulling those in unless it's required because it wants to minimize the context and give you the best success for with actually, you know, doing the job that it's trying to do. I also suggest that as your projects grow, when you're working in a single project, the code base is going to grow. conventions are going to evolve that the LLM can start to figure out on its own. You can slowly remove rules and so don't waste the contextual overhead of creating rules telling the LLM to do that when it does that. Now, over time, if you see the LLM start doing very stupid things like using horrible file names or unclear variable names, go ahead and create a rule. But most likely, you are not going to need that. and just let the LLM have rules that it needs. And over time, as the project grows, like I said, you can also remove rules and see if the LLM is able to operate properly by just using the contextual information it finds in other files or in the indexed project that it uses. I want to also let you know that any rule system you use, it's not going to be 100% perfect. It's so much better than it was even 6 months ago and it's leagues better than having one giant rule filed that's in every context. But notice one thing, this is still non-determinism that we're dealing with with LLMs, especially with the agents and the descriptions or the file paths or even the always rules. They're still up to interpretation. And so it's still sometimes going to make mistakes, but again, that's when you just go back in and tweak or correct the rules or have the agent correct the rules or add more context or more examples and negative examples to the rules. So don't just think that you're going to create a rule one and done and it's going to be perfect. It is a constantly evolving system that you're working with that you need to train to improve, but it will get better over time. and it and it is amazing how well this works as you evolve your rules into a project, but just know it is going to make mistakes from time to time. So, look, thank you everybody for joining me. I'm going to wrap this video up. I know this was a long video, but there was a lot of information to cover and I also probably went fast. So, again, chapter markers are in here. Go back, check out the rule types, check out the repository. Again, um you can look at the uh GitHub repository. The link is in the description. You can read all about the rule generator. You can clone the project. You can run the script on your own projects, create and start your own project, or just copy the rule generator to your own cursor folder, and you'll be ready to start asking the AI agent to create rules for you that respect the four rule types, superpowering your ability to use cursor. Remember to use ma macros and manual rules also. They are powerful and sometimes it's just quicker to type a command than typing out a whole instruction and hoping the LLM gets it right. Which is again why I do that for Git Push. And finally, finally, finally, please like this video if this was helpful. Share it, subscribe to the channel, and I hope to see you in the next one. So, bye for now. My name is Brian and this is BMAD Code.