# 7 Antigravity Features for Vibe Coders

Published: 2025-12-03

Google's new anti-gravity AI coding tool is blowing most of the competition out of the water. So, in this video, we're going to go through the top seven features and tips that'll get you the most out of it because most people are just focused on how good Gemini 3.0 is. Even Sam Alman descended from his lofty throne to give Google a shout out for their model. But people are missing the boat big time on just how big a step anti-gravity has taken toward a true orchestration first approach to building software with AI. It's part of the reason I was able to build this AI thumbnail designer with Nano Banana Pro in just 10 minutes. So, what we're going to do in this video is look at anti-gravity in the lens of a real project and talk about where it really shines. And like always, any prompts that I use will be available in the description below. So, let's get into it. So, one of the real pains with tools like Claude Code or Codeex is that you don't have a lot of good visibility into what your different sub aents are actually doing. Now, Instep's anti-gravity's agent manager, which is like a mission control dashboard, but for agents. Now, most people are used to this like chat interface style of working with agents inside of these tools, but inside of anti-gravity, we have this like inboxbased system. And so, it lets you spawn, monitor, and interact with multiple agents that are working at the same time on different pieces of your project. So whether they're working across your editor, whether they're in the terminal, whether they're in the automated browser, you can interact with and see progress checkpoints from all of those different agents working at the same time. So let's say for example, we are working on building a personal training uh agent based assistant that can help people build training plans and keep them accountable to those plans. Well, we could come through and we could kick off our first agent, which is a researcher. It's going to go out. It's going to investigate how Google's agent SDK works and it's going to come back to us with insights. Maybe for our second agent, we want to go through and we want to actually mock up a front end for what this chat interface might look like. So I could go through, I could kick off that agent. And then last but not least, let's say I want to have a Python fast API backend so that I can use this agent kit from Google and I can say, "Hey, go set me up a very basic backend uh with a health check endpoint." So I could kick all of this off and now all three of these agents are running simultaneously and I can come in here and I can check each of them and follow their actual process through. Now the thing that's pretty cool about anti-gravity is again it's based on this like inbox system where you are going to get notified every time there's something meaningful for you to come through and check out. So we can see now that we have all of these different agents that are actually kicked off and running. So, if we were to go in, for example, to the research agent, we can see that it thought about what it was going to do. It built its plan. It's now looking at our project, and it's going to go out and it's going to continue doing its research. And so, it's actually using this embedded search functionality inside of this research agent to go out and actually search the web to find all of this different documentation. And we can actually follow along as the agent does that in real time. But if we were to pop back out now to our inbox, we can go through and we can see if there have been any other updates from any of our other agents. So we have this implementation plan now for our personal trainer kind of chat UI that we asked for. We have research being done on the actual like endpoints and how we're going to use this SDK. And then we also have our backend being configured with our fast API request. So now that we know how to manage this team of asynchronous agents, that's going to help us move a lot faster when we have these projects that we need to be working on several large tasks at the same time. But what do we do if the output of some of these agents needs to be tweaked? Well, the next tip addresses that. So what do you do when your coding agent gets 75% of the way there, but then veers offc course in the little details? Well, with tools like Clawude Code, you often have to start over and undo everything and like start from scratch with your corrections in the next prompt. But with anti-gravity's asynchronous feedback system, staying in that orchestrator first mindset is very easy. So, let's say we're in this feature here where it is actually moving through as we speak and it's attempting to build out this chat UI. and say we see down here in this task list that it is intending to go through and create charts and graphs and like let's imagine in this case that this isn't something that we actually even want. Well, we can leave an inline comment here and we can say remove this feature from the MVP entirely, right? And so we can go through and just like we would inside of a Google doc, we can mark this thing up. we can review the plan and then we can submit our changes. So let's say that there were three or four different things that we wanted to change while it was in the process of actually building. So for example, we could go through and also modify the message list. We could also come through and modify this and say only support images for now. Right? So now we have two comments that are going to get passed through when we decide to submit these changes. Now, the thing that you see here that's really cool about anti-gravity is it has very frequent checkpoints where it's going to look for any sort of comments that you've given and update its plan on the fly to now integrate any of those changes that you requested. And so, the thing that's really cool is that you can do this across plans, you can do this across task lists, you can do this across images that have been generated or screenshots that have been taken. You can use the same commenting feature, which we'll look at a little bit later, for pretty much everything inside of anti-gravity. And so this solves one of the biggest pains of other AI coding tools, which is having to stop and switch context frequently in order to solve problems. And so with this type of workflow, we're staying in that vibe flow a lot longer, all while retaining really high quality outputs. And so this is part of why I follow this plan, refine, and orchestrate process no matter which tool I'm using because it allows us to have these really frequent check-ins where we can make sure that we're really staying true to the plan. Now, if you want a free course on that framework, you can find that in the description below the video. But even this feature is really powered by something that not a lot of people are talking about with anti-gravity, which is its artifacts. To really vibe code or AI code like a professional, you absolutely need to approach this stuff with a human in the loop approach. And artifacts like this walkthrough that we are looking at here are the core of what enables that inside of anti-gravity. They're like an agent's proof of work. And so we want to be very deliberate about how we review these things and how we interact with them as part of the development process. six types of artifacts in anti-gravity, but in this video we're going to focus on three of them. First up is that we have tasks. So let's say that in this case we are trying to refactor the UI that we got and we kicked off an agent. Well, the first thing it's going to do is it's going to generate a task artifact which we looked at this earlier. So we could come through for any of these tasks that it is moving through and we can provide inline comments that will update this plan as it's being implemented or before it gets to the actual implementation. Second type of artifact implementation plan. So these are going to be more structured descriptions and approaches toward what we are building. So in this case we're trying to revamp the front end to be more professional, to be more modern, to pop more. The focus is on bold simplicity, breathable whites space, so on and so forth. And so it is going through and it is breaking down for each of those tasks that we have. What is the actual implementation plan for each of those? And so we have all of those things outlined here, what we need to modify, what we need to create, what we would need to delete. All of that is going to be fully integrated into this artifact. Now again, if there was a major concern that we had in one of these pieces, like we didn't want something specific done in the layout or in the training plan viewer, we wanted it done a different way, we could simply leave that inline comment and we would be good to go. Now, one of the things that I really love about anti-gravity is that anytime it completes a feature or completes through one of these chats and does something meaningful, it creates a walkth through artifact, which is basically a stepbystep sequence of changes that it actually made. So, we can keep this running change log, read what it did, and make sure that it didn't do something that we specifically don't agree with. So, if we were to go look at the updates that it actually made, uh, it's using a lot of gradients, which I I really don't like the amount of gradients that it's using. So, I could pop back in and I could say that we are using way too many gradients, and have it move through and actually update that. So, again, just like we did in our plans or our task, I can come through and I can give feedback. So, I can say, "Hey, I don't actually like what you did here. Uh, that shouldn't be the primary color in this example." And then I could say I don't like how much you were actually using these gradients. And so we could move through, we could submit those changes and then it is going to go through and is going to update based on what it did. So we have like three or four very distinct different touch points in the development process where we can give direct feedback to the system in the tasks, in the implementation plan, in the finalized walkthrough of what it built in these screenshots. All of those are different opportunities for us to inject our feedback directly into this development process. So this whole system really enables us to stay in the flow and avoid painful redoss of our work or we have to like entirely start over from scratch on things. Now one of the more powerful features that results in artifacts is the browser automation. So when tools like claude code and cursor began supporting MCP servers, one of my favorite workflows was what I called self-healing UIs and that basically solved the pain of developing a feature, giving clear UI guidelines, but then getting a crappy result out the other side. And so what we would do was we would use browser automation MCPS to take screenshots and then just pass those screenshots into the language model and have it self-grade itself and self-improve what it had built. But now that is basically built in with anti-gravity's Chrome browser automations. So what we can see here is that Chrome is actually automatically checking right now all of the different components that it made and how well it is conforming to the feedback that we had given it. So it's able to actually use the browser. I'm not touching anything. It is moving through and it's doing all of this clicking by itself in order to actually test what it had built. Now when we go back to our walkthrough, we can actually see that this audit recording is now integrated into this artifact, which again helps us keep that running tab of what we have changed. So all we did was comment on this recording and ask it to grade itself. So I said on a scale of 1 to 10, if the results below an eight, recommend updates. And what it did was it went through and it realized that while the chat coach and the training plan were well conformed to our new UI guidelines, the progress tracker was not. So now we can tell it to proceed with making that change and it's going to go through and it's going to make the change. So in effect, you can get automated UI and performance feedback through the integrated Chrome browser automation and you don't have that headache of having to manually configure all of these different tools and orchestrate them together. All integrated into one development experience. So pretty cool if you ask me. But the question now becomes, can we actually automate more processes like this inside of anti-gravity? And the answer is yes, we can. And so the way that we are going to do this is with custom workflows which allows us to store and reuse prompts kind of like claude code slashcomands. And so what you're going to do is you're going to go up to additional options inside of your chat and you're going to go to customizations. Now once we're inside of here we have two options. One is for rules, one is for workflows. So what we're going to do is we're going to go through and we're going to configure one just for this specific project. And we could call this for example our debugging workflow. Now I find these workflows are best for repeatable structured processes. So in this example I'm going to actually take a cloud code skill from this Ora superpowers GitHub repository and I'm going to try to turn it into a workflow that we can use inside of anti-gravity. I love this one cuz it is really good at helping us debug problems that don't end up creating a whack-a-mole type of situation. So, it tends to actually solve the right problem the first time. And it does that through this four-phase approach. So, what we're going to do is we're going to go back to anti-gravity and we are going to say this is a workflow for debugging root causes. And then inside of the content, I'm just going to paste in all of the content from that repository. And I am going to just cut off some of the top pieces that I don't think are necessary for this. So, let's actually test this thing out. If we were to go in here, we'll notice that the image upload isn't actually working despite the fact that it should be. So, if we were to pop back in, we could now type in this slash command or this custom workflow for debugging. And we could tell it the image uploading in our chat is not functional. So, we can see now just like that workflow specified, there were four phases. The first one was investigating the actual root cause. So it is moving through and it's now following that specific workflow that we had outlined pretty reliably. So this obviously solves that problem of having to keep, you know, some word doc full of all of the different prompts that you want to use and then paste them in every single time. we can just keep all of those repeatable workflows inside of our actual development environment, whether it's in this specific project workspace or whether that's more globally defined across our entire computer. Now, if you want three of my most used custom workflows for anti-gravity, you can get those for free in the description below the video. But these workflows again they allow us to codify our best practices and operating procedures for building. But even with the best workflows, the best artifact usage, the best agent usage, if you don't get this next thing right, you're pretty much setting yourself up for pain. So when you first sign up for anti-gravity, you have three options for this review policy. Always proceed, never asks for anything. agent decides if it's going to proceed or always ask for a human's review. And basically what this means is how autonomous do you want this really to be? Now, while it may seem like a simple setting, there are some quirks I've noticed in my hours using anti-gravity so far that affect what you should choose. And this is actually a really good example. I have noticed that when you leave it to agent decides if it's going to ask you for review or not, it almost always does not ask you for a review and proceeds anyway. So, in this example of the UI revamp, I did not actually get a chance to review this plan where I could have gone through and realized it was about to do some stuff I didn't like. Now, for something as simple as just changing colors in the UI layout, that may not be a big deal, but when it comes to building bigger and larger and more critical features, that can be a real problem. So, I recommend if you're just getting started with the tool to toggle on the always ask for review option and then only come back and update this when it's starting to become maybe a little bit annoying for you or is actually slowing down your process too much. So, this is really an important principle to understand. If you really want to be successful with vibe coding, you really do need to adopt a plan and then execute type of approach. Just letting the tools run rampant on your codebase is really a pretty bad idea. And this setting is the lynch pin of that type of plan and then execute type of strategy. So make sure you choose the correct setting based on your experience. But given all of that, should you even be using Gemini 3.0 inside of anti-gravity or is there a better option? Well, let's find out. Now, the usual temptation with releases like this, and I'm just as guilty as this as anyone, is to just use Gemini 3 Pro for everything. Do the same thing when Opus releases a new one, when Sonnet releases a new one. We just try to abuse their best model and see what it can do. But that is a problem because you're going to burn through your usage credits really for no reason. So, inside of anti-gravity, you basically have three models to choose from. You have Gemini 3 Pro high and low. You have Claude Sonnet 4.5, the standard version and the thinking version. And then you have GPT OSS. So which of these should you actually use? Now for complex multifile operations or multi- aent orchestration, Gemini 3.0 is pretty great. So, specifically inside of anti-gravity, it's really good at solving complex problems and generally getting hard things right pretty well off the bat. Now, for complicated problems and debugging things, Sonnet 4.5 tends to do a better job. So, if Gemini botches something or isn't able to get past a problem relatively quickly, there's really good odds that Sonnet is going to get it right. Now, for more admin style, there's no way I could possibly mess this thing up type of work. GPTO OSS is again pretty good at those more housekeeping, administrative type of tasks that are going to be pretty easy to get right. But that being said, I would not trust it with the keys to the kingdom. So basically, use Gemini anytime you're building robust things or pro tip, anytime you're using something that is an anti-gravityspecific feature because what I have noticed with all of these model providers is that their models tend to be optimized really well for their tools. So, if you're using something that is a really native to anti-gravity type of feature, you're probably going to get better performance with Gemini than you would with Claude. So, default to Gemini 3 first for anti-gravity specific features and then use Sonnet as a fallback as it's needed. So, there you have them. Seven tips to make you a top tier anti-gravity user. So anti-gravity's power really does lie in being an agent first approach to building these things. It really wants you to stay in the orchestration mode and get out of the being concerned about the syntax of the coding mode. And so if you appreciate that type of approach, it's probably one of the best tools on the market to do it and it is currently free. Now, if you want to see a video where I used Gemini 3.0 specifically to rapidly clone an 8 figureure app and turn it into something slightly different, I will link a video above where I do exactly that. And as always, if you like the video, make sure to subscribe. I will see you in the next