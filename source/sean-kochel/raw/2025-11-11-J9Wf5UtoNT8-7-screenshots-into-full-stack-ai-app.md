# 7 Screenshots Into Full Stack AI App

Published: 2025-11-11

The vibe coding universe on social media has some pretty giant gaps. The education on going from idea to functional MVP that isn't Instagram but for cats is almost non-existent. That's why in the last video we used a vibe designing system to build the initial screens for our app using Google Stitch. And it was like lovable but only for design, no functionality. And everyone wanted to see how we could take those screens and turn them into an actual functioning app. Front end, backend, database, the whole nine yards. So that's what we're doing today. Going from conceptual screens to functional MVP in about 9 hours. If you're new to the channel, my name is Sean. Over the last 6 years, I built my own SAS to 20KMRR. This video is great for anyone that considers themselves like slightly technical at least, but is having a hard time bridging the gap from those great ideas for what things could be fully through to actually having a functioning version of that app. So, we're going to go through the exact step-by-step system from the screen to coloring in all of the actual feature details, breaking them down into epics and stories, and then actually building the thing out, front end, backend, database, APIs, language model, integrations, everything. So, if you want to build cool in 2026 and beyond, then this video is for you. All right, so these are the screens that we are starting with that we built in that last video. So we have this gamified kind of onboarding process. Then we're going to hop in and build out an actual chat functionality. We'll have a version of this insight journal where people can go back and look at past chats. And then we'll have some basic settings. So the thing is this is the front end, right? This is what the user is going to see. We're going to make sure we can build all of this out. But there is that backend side. So while this looks like, hey, we just need to build these front-end components. There's actually a lot that's going to be going on. We have all of our databases, the APIs, how are we going to store information, how are we going to retrieve it, what all the payloads need to look like, all of that type of stuff. So, we're going to try to get all of this built out for a like P 0, like priority zero. What are the features that really need to be there in order for this to get people the value that we're promising? And then from there, as we start getting users, we'll start iterating on adding different features in and all of that stuff. So, the best way to get started with this process is number one, while we're here, we just want to click on all of these. So, I'm doing like a a shift click or commandclick, and I am going to just download these. And so what this is going to do is it's going to give us a zip file on our computer that has every single image and also the structure of the HTML under the hood that was used to actually build this thing out. Now once we have all of those things downloaded, then what do we do? So the first piece of this is that we want to have a really clear understanding of exactly what it is that we're going to build for this MVP. And so I have a prompt here which again you guys can access below the video that helps us break down exactly that because we need to have a really concrete understanding of you know these are all of the screens but what is it really that I'm trying to build and so we're going to go through and basically we're going to break down well what are all of the different feature specifications for that. So if I have for example an onboarding flow well I need to actually break down what are the different features that are involved in that flow and so we have this prompt which again is below and then at the very bottom of it we're passing in what is the core concept of this MVP. So I'm giving the highle concept of what this app is and then I'm just breaking through from my understanding of the designs that we made, what I liked about them, what I might change, what I know I want to the like experience on a high level to be like we're prompting out the MVP for this app. And I like to think through this of what are the different screens, how is a user interacting on those screens and then what happens, right? So if I go through the onboarding, then what happens? What are the different things someone can do? And so the way that I've made this prompt is first it's going to ask you clarifying questions about the app that are ambiguous based on the prompt that you gave and the outline of your MVP. And so it's really valuable to go through and actually answer these things which I did. And so out the other side we get a very detailed planning document that has every single feature listed out highle user flow what users should experience as they're moving through things different edge cases that we need to consider primary UX considerations that should be in here and then highle dependencies like what other features does this depend on now the thing to note is that each of these has a priority so P 0 would be things that absolutely need to be there for this to be a functioning MVP. And then we get P1, which are things that you would want to have at launch or shortly after that are still very valuable and core to the app. And then from there, we have like P2, which is not really a priority right now. And we might even change those in the future. And so the way that we can make like actually building all of these features out an approachable task is by doing what a real product organization would do. We can take each of these features and start breaking them down into epics, which are basically like major deliverables. And then inside of each of those epics, we can have stories, which are the different individual components that are going to roll up into that epic. And then inside of each story, we're going to have tasks that need to be accomplished. So in this chat interface, for example, we might have an epic for the actual chats user experience. We might have one for the context management layer, how it's going to actually manage the context within the app. We might have one for the prompt engineering. How are we going to take the user's inputs and like apply these different mental models to it? How are we going to do all of that? Those might all be epics. And then within each of those epics, there will be substories that break that down. So, for example, in the context management layer, there might be different stories about how we're going to store that context, how we're going to maybe store it into a vector database, how we're going to retrieve it intelligently. Those might all be different stories. And then inside of one of those stories, like storing it in a vector database, there are going to be a ton of different tasks potentially that are needed in order to make that thing happen. And so I have a prompt for you here that you can use to kind of make that a reality where we can take that PRD that we had and we could turn it into those epics and stories. Now what you're going to get out the other side of that process is a zip file that has everything you need inside it. And so all we're going to do is download that zip file and just drag it into our actual project directory. And so that's what we're looking at here. Now, I decided to break this project down into a front-end repository, which will have the mobile app, and then a back-end repository, which is where all of this like language model processing and all the business logic is really going to sit. Now, depending on what you're building, you might not need that, but that's what we're going to be doing here. So, in the root of this project, I've now just dragged over that folder that I got out the other side. And so inside of it, we can see a few different files. The first one is going to be our readme, which is basically the root pointer. So if a language model was to get referenced into this directory, it's going to read this file and understand where everything lives and how it's meant to be used. Then inside of this PM notes directory, we have that PRD file that we got out the other side in that first step. that's really explaining the heavy details of what needs to be inside this app. And then we have this folder called features where we've taken every single one of those main features that we had from the onboarding demo all the way down to you know the payw wall. And so we're going from this highle feature and we're starting to drill down into the details. So for example in the onboarding we're going to have an epic for the actual like problemsolving capture. And so again, we have this index file that kind of gives a highlevel hookin of, hey, this is what we're trying to do in this epic. And then we have all of the different stories within it. So when we go to build this like demo onboarding feature, one of the epics is, hey, how do we capture the user's problem and do stuff with that? And so what are the different stories inside of that story where we're going to actually trigger the demo flow? we have this story where it's going to actually recommend a mental model to the user based on their problem like which one's most appropriate to help you solve this problem. And then we're going to give them some like example inputs to kind of guide that demo. And so the thing that's valuable about this process is that we're actually referencing where the feature details live. And so when this, you know, spec driven process goes out to start building this thing, which we're going to get to, it's going to actually reference all of the details about this feature. And so this kind of pattern of having a feature, having the epic, and then having all of the stories within that epic is going to carry through for all of our features. So we can actually build this thing out knowing that it's doing exactly what we want it to do. So, what we're going to do from here is we're going to go into each of these epics that we have, and we're going to now drag and drop those images we had that we downloaded into these folders so that it knows what we're trying to build for each of those features. So, I'm going to do that offscreen for a second and then we will come back and look at what we did. Okay, so that's exactly what we did. So, we went through, we opened up the image, we looked at which section it belonged to and we just dragged it in. So, for example, in the guided demo conversation, this is approximately what we want that screen to look like. So, now that all that setup is done, let's get into actually building this thing out. Now, full disclosure, if I was to be running this in my real dayto-day workflows, I'd be using Cloud Code. But since not everybody uses cloud code, a lot of people use a tool like cursor, I'm going to start this whole process off inside of cursor to show you how I would approach specri development with all of these features inside of cursor. And so the key to really doing this well as a beginner or even as someone more intermediate that wants to build something like kind of robust but not screw it up is to move a little bit more slowly but do it on rails. meaning using a system that won't let details slip through the cracks. So, if we thought of this like a video game instead of an open world where you could literally walk anywhere, this would be like having a storydriven game where you're kind of on rails and you're proceeding from task to task to task and not just wandering all around aimlessly. So, this helps us avoid getting lost in the sauce. The tool that we are going to use to do this is going to be GitHub's spec kit. The reason I like this is it still gives us flexibility to define what we want in the app like the epics and the features and everything that we just moved through, but then we can still use an on rails system to clarify our plan when it needs clarified and then actually move through to implementing that thing in a way that again does not drop details. Now, if you've never used it before and you want to see how to get started in the different features, I will link a video right now that has those features outlined. It's like a tutorial on how to use specit. We're just going to get into actually using it. So, the way that you use specit is in cursors agents. And so, the way that I'm going to start this off is by typing in our specify command, which basically pulls in spec kit. And then the first thing I want to actually do is just set up really quickly that backend repository. And so I'm going to tell it set up a basic Python fast API backend with a simple health endpoint inside of the backend repository. And I'm going to hit enter. So now that we have that backend repository set up, there's one more kind of pre-work step that is really helpful to do at this stage. The caveat is that if you don't do it the way I'm showing you right now, your other option is to create a specific design epic that is going to create you a tokenbased design system. Now, there's a lot of camps out there when it comes to UX and UI design, and a lot of them say that you should worry about like colors and all of that type of stuff at the end more as like a flavor as opposed to getting so caught up in the different colors that you have in your app, but I know a lot of people like to see like what this thing might actually look like. So, that's why we're putting this UI design phase here. And so what we're asking it to do is we're uploading all of those images we had and we're saying create me a tokenbased design system based on these images. And so what that's going to do is it's going to look at the different colors, the rounding of like button borders, the layout grids, all of that type of stuff. And it is going to create us a tokenbased design system. That means when we go to actually build out these features, which we're about to do, it's going to know which colors it should be using when it goes to build out all of those individual features. So, we can do this one time and then we just have it in place. So, again, you can just use a prompt like this or you can go in and actually create an epic around this as like a feature zero or epic zero before you kick off the process. That is up to you, but I'm just letting you know of those options. So, now we're going to get into actually building out our first feature. And so, what we want to start off with is giving the agent the context for this specific epic folder. So, what we're going to do is we're going to hit the at command and then I'm going to paste in the path to this specific epic. And so, the first feature, right? So, we have that feature folder. Then we have our first epic which is the actual demo like initiation capturing the actual user problem and then beginning that onboarding process. And so I'm going to reference that markdown file that had all the details about it. And then I'm going to type in slashspec kit and we're going to run the specify command. So the specify command is where everything starts out and we want to really break down the details of what it is exactly that we are about to build. And so this thing is going to roll through it very quickly and actually break down that epic into the like a a specification file that can actually be used to move through and start building all of this stuff out. And so what you're going to have inside of this spec document is basically a detailed specification for that specific epic. Now in a real world environment, you really do want to go through this and make sure you are on board with everything that it's going to build. But for sake of this being a tutorial, I'm going to go through and I'm going to run the next command, which is spec kits clarify. And what this is meant to do is look for ambiguities in our plan and make sure that there's not some like serious consideration that we are neglecting. And so what this looks like in practice is that it's going to give you a series of questions and it's going to give you recommended options for how you can overcome this problem. So for example in our planning document we have this edge case what says what happens when a user navigates away from the flow and then returns but we never answered how that problem should specifically be solved. And so it's going to give us a few different options. And all you really need to do is tell it what your response is. So in this case if we wanted it to persist but only for a certain amount of time we can just say B. And then it's going to go through. It's going to fill in those details in our stories and it's going to continue with asking us the next question. And this process repeats until all of the major ambiguities are handled. Now, this is a huge reason why I love specdriven development processes that again are like on rails with a tool like GitHub specit because it finds these really critical moments and does not allow us to pass through to the next stage if we're making a mistake because remember when you have ambiguity the model is going to determine how it wants to handle that problem and it often does it poorly. So after we have this plan, we can come through and run the next stage of this process which is planning it out. So we need to take now all of these specifications for this epic and break it down into an actual plan, right? How are we going to move through and actually execute on all of these things systematically. Now once this thing is done, we get a really detailed plan that we can pop in and look at in the plan. Markdown file. So everything from a highle summary down to the technical context of like how these different features need to actually be implemented. What we need to actually include inside of like this implementation when we get down to actually like building tasks tasks and implementing for example what does the data model need to look like? What do the API contracts need to look like? All of that stuff is being outlined in detail so that when we get down to actually implementing this thing and planning out the task level, it's going to know exactly what it needs to do and it has a structured plan that it can reference back to. So we can come down and we run the next command, which in this case is spec kit tasks. And so this is going to take now that entire plan that we have, all of the details and context that we have about it and actually break it down into a stepbystep task list which we can then use to go and build from. Now the next command that we want to run before we start building is this spec kit analyze. So what this does is it cross references all of the different artifacts. So like your plans and the different tasks it generated and all of that stuff and make sure that it didn't miss something. And so the reason that I like to run it this way is that if you looked at our task list, it didn't actually have references to the images that we uploaded, which was the entire point of this process. And so we tell it to analyze it and understand where that gap exists. And so it goes through and it looks at everything that was intended to be kind of done in this story, all the different tasks and everything versus what was done. And so what you're going to notice is that the image coverage was basically zero. Meaning it's not actually using the images that we uploaded. And so this gives us a hookin point to say, "Hey, I need you to go update all of those stories and tasks so that we're actually including the images that were intended to be used." Now that we have that in place, we can move through and actually start implementing from these tasks. So, I'm going to open a new agent just so we can have a fresh context. And I'm going to tell it to move through and implement. So, I'm going to use the speckit implement command for the tasks in this specific task folder. So, I'm going to link where those tasks were. And then I'm going to let this thing run. So, now it's moving and grooving. It has its plan. It has a to-do list. It's going to move through that list, building out every single story in phases. So, it's going to move through from the setup, which it just completed, through to the core infrastructure that's going to be needed to run this thing, and then all the way through down to phase six. And then from there, we will look at what we built. All right, guys. So, this thing just finished running through. And as far as the functionality of it, everything you see here was pretty much a oneshot with the exception of I changed a little bit of the copy because I didn't like some of the copy it was using and some of the spacing is off relative to what those images were. But this is all tiny details that we can refine in. And so we have this main screen. We can hit begin. Welcome challenger. This is the type of copy that I'm going to change, but that's fine for now. We have our state the problem screen or we can come in here and just type in stuff. We can continue to the lens selection. Choose your lens that you want to look at this problem through. So we could say for example, first principles thinking. Select the lens. And then we have this recommendation. Now, this is something that technically would process on the back end and it would try to actually match what the person's problem was to the mental model, but that's stuff that we can address later now that we're looking at like what the actual UX is looking like. And again, there's like some styling things that need to be tweaked here. I would probably shrink this size so that this can all fit on one line. I would make this match button probably a little bit smaller and drag it up and make this look a little bit tighter in one view. But then from here we would click the the next and we haven't built that far yet. So we have this like hey you can start over or whatever but this is just the basic demo. So now like I said I don't want to pull the wool over your eyes in terms of like what worked and what didn't purely based on the spec kit running through that task list. And so we had one or two situations where it wasn't following the design the way that I wanted it to. And so, for example, in that lens screen that we were looking at where we got to choose the mental models, it was just giving the user one model. And so, what I did was I went back to the reference reference image. I uploaded it and I said, "Hey, you kind of missed the mark on the screen. Update it to look more closely like this." Then it went through and made those changes. And now we're left with a screen that looks like this. And if we were to go back now and look at our actual screen that we were basing this all on, it did pretty well, right? This is pretty close. Again, there's some spacing issues and some other things like this. You'll notice if we were to scroll in here, these like very subtle kind of gradients here didn't make it through to the design. And that's something that we can just tell it to do. So, how I would go about doing that, for example, is scroll in a lot and then kind of tell it that each of the up next cards needs to have this kind of subtlety. Okay? And so, this is what it would look like trying to fix that where I'm going to upload it. I'm going to tell it exactly what I mean. and it's going to go out and it's going to fix that thing. But outside of those little UI changes that we're going to be making, let's look at the broader scope of what exactly it is that we made in that task. So, this task list technically did two separate things. Number one, we built out all of those components that we were looking at inside of the demo that we just did. And it has a lot of different things going on inside of it where it has all of the API endpoints for sending the data and receiving the data. It has all of that core routing logic built into it and it even has a pretty robust backend with tests already built out. So when we get down to actually wanting to work with this thing and really send the requests through, we have the API entirely built with all of the endpoints that handle the different things that we need like sending and receiving the problems, getting the recommendations back, managing the session. All of that stuff is inside of our API and we're just going to need to obviously connect those two worlds together. So if we were to just pop back to that thing it just did, we can see it went through and made this tighter. And this already looks like a lot nicer. Now, again, there's like little styling things we can do. I don't like when UIs feel very sprawling like this. So, I think I might compact a lot of this down, but that is all secondary to the fact that this thing is actually working. Obviously, not sending the data, but we'll get into that in later steps. So the big takeaway here, we have all of those designs that we made. And if what you build doesn't match that design onetoone, maybe it doesn't properly hook in the token design system you made or maybe messes up the formatting of the things a little bit. You just need to keep in mind, keep in context that it's built out a lot of other functionality at the same time. And so all we need to do is go back and make these small little iterative refinements. If you were to have something that's 90% done and just upload an image and say, "Hey, we kind of missed the mark a little bit. You need to fix this, this, and this." It does it very, very quickly. So, if the first pass doesn't 100% meet the mark like this one kind of did, that's fine. That's expected. That's going to depend on the tool you're using, the model you're using. Some of them are better at different things, but we just need to continue pushing forward. So, if we were to go back now and look into our docs, what is really the next thing that we have to do? So we did epic one of this feature one onboarding demo. So we created this system for capturing the problem and selecting the lens that we want to use. But what we really need to do now is create that next piece which is this guided demo conversation. And so we're going to just literally repeat that same exact process that we went through in the beginning. We're going to go through we're going to spin up a new agent. We're going to run the spec kit specify. We're going to pass that in, right? Our directory which is right here. We're going to pass this in and we're going to say, "Hey, go build this thing." And we hit enter. And so again, what is the process from here? We're just repeating that loop now over and over and over again. So we've done a lot of the planning. We've refined the plan. We're going to continue to refine the plan. And now we're just orchestrating this system. So we're going to run through the epic. We're going to plan it out. We're going to break it down into tasks. We're going to implement the tasks. And then we check what it did. we validate it against what we were expecting. So now we're going to run through this process for a big chunk of these features and we're going to come back and discuss anything really meaningful or different that doesn't fit the mold of what we literally just did. We'll talk about those, but I'm going to run this process through for the next series of features and epics and then we will review everything that happened and I will let you know how long it took. All right, guys. Like I said, I would hop back on if there was anything like outside of the ordinary that I found myself running into. And in this case, what was happening as I started testing with this next feature is that it needs to store the user's session so that it knows like the progress of that person through their journey and the onboarding and all of that type of stuff. And what was happening was that it was storing that in the back end. it was storing that in the server's like memory like it's running memory and so what was happening was every time the development server would restart I would lose all of the session ids and all that stuff and so I'm putting in place a very very lightweight database to run locally on my computer so I can just test this thing and the reason I'm doing this with a Postgress database is if I want to put this up on like superbase for example once it's ready to rock it's going to be really easy for me to just import the database and the schema schemas and all of that stuff into superbase. So I am setting up this really low really simple lightweight local environment just for like testing and building purposes. But outside of that again it's been smooth sailing. It's just moving through creating the components. That process took about 45 minutes um to move through and create this next epic which was a pretty involved epic. There was actually a lot of stuff that had to be set up and so just keeping track of the time that is where we are at so far. All right, guys. So, we've been at it for I think like probably four hours at this point, dealing with a few different things. So, I'm going to go through where we are at right now and what some of the takeaways so far have been that you should really consider when you go through and start running this process yourself. So, we have this part here where the person states the problem. Let's just say someone that's struggling to lose weight, for example. Okay. Then, we pick like what's the mental model that we want to use to actually solve this one. So, we will pick first principles. The reason I'm picking this one is each of these is going to have their own prompts under the hood that guide the system in guiding the user. So giving the system like hey if it's you know second order thinking is the mental model. Well there's specific ways that we should think about engaging with the user. So the one that I have built out right now is first principle. So I'm going to pick that. Um we still have some dummy data in here that we can clean up. And then we come into an actual chat screen. And so basically the way this works is this message pops through and then it asks the person the first question. So um what would it need to look like to say, "Hey, I fixed this." And then the person kind of goes back and forth. And now the system is reading that prompt that it has to guide someone through. And it's asking follow-up question after follow-up question to try to get a sense of where this person is at. Now, once they're done, they click this get uh create summary button. And then basically what that's doing is it sends this thing off to the language model to actually summarize that entire chat. So, it's going to take the last few messages of the chat and it's going to generate like an insight based on it. So, in this case, the problem is that the user is grappling with self-image and self-worth, believing that weight loss is the key to achieving confidence and energy. when in reality these feelings may stem from deeper personal and psychological factors unrelated to weight which I mean could be true right and so we have these really nice styled cards like you'll notice this little kind of boxed outline with the little icon and then kind of summarizing what the insights from the chat were then it has these suggested actions which might need to dial in exactly how this logic works but then again if we go back and actually look at what some of our screens looked like um that kind styling. It's very obviously using like this kind of component style that we had in our designs. So, doing a pretty good job at like sticking to what we asked. The thing is I didn't actually provide this narrative feedback kind of style of summarizing things for the user. So, it's not surprising to me that it didn't build this out, but in later feature epics when we go through and refine things, that's something that we can work on. So again, in those like four or so hours that we've been working on this, we got through this full demo epic and then we got through this chat interface epic where we were building what the actual chat like runtime environment is. What is the kind of process for creating a new problem inside of the app? And now we are moving on to this epic for the actual insight journal. So, what we're doing now is we're taking like a little interim step because what this did not have and again this is something you can add into your prompts if you need to or you can do it as a standalone task is that we don't have navigation set up inside of the app. And so that's why I'm going back to the PRD that we had and I'm just telling it, hey, can you actually build me out the navigation for this thing so that I can um start seeing what everything like past that demo onboarding experience is going to look like. And so there's a few takeaways so far being like four or five hours into this thing and spending an unfortunate amount of time in some earlier features that I shouldn't have spent that much time in. Number one, be ruthless about how you manage your version history with Git. That means using work trees, using proper branching, not making the mistake of working on two separate features that should be in separate branches within the same instance of your development environment. You want to be really disciplined about having proper version control with this style of like spec driven development. Number two, what I found is that moving through the planning phases with spec kit using a model for example like cursor's new composer model, you get through that process incredibly quickly. And so what I've ended up doing in this app is that I use a lighterw weight model like the composer model to do all of the planning inside of specit. So the specify command, the clarify command, all of those initial commands that we were going through up before we implemented. I'm using a lightweight really fast model so that it doesn't spend so much time in that planning phase when the reality of the situation is that it's already very clearly outlined how it should go about doing this thing. It just needs to do it. So it's very much on rails and so we can use a faster model to do that. That being said, I have started using a more powerful model like cloud code to do the actual implementation because I found that cursor was just being a little bit of a pain in the ass even with sonnet or codeex 5. It just wasn't doing things to the extent that I wanted it to be done. And so I started using claude code so that I wasn't spending as much time having to circle back through bugs that shouldn't have been there in the first place. So thing number three, do not overengineer the tech in your MVP. It can be very alluring to look at your PRD, see all of these things that seem easy to do, and then just decide, hey, yeah, I'm going to try to jam that in. That would be pretty valuable. and you end up spinning your wheels and spending a lot of time debugging technical issues that shouldn't have really been there in the first place and aren't the real needle mover for your project getting into the hands of users. An example of this is I spent about three and a half hours debugging issues and trying to work through trying to retain the users's state in the session as they moved through the onboarding phase and then trying to take into account all of these different scenarios of whether or not they exited out of the onboarding before completing it. trying to save the status of that session, sync it with the database, check which one was actually the one that was most valid, pulling in that and using that information. It was just like a a ton of work that realistically didn't need to be done for an MVP. So, do not go down the rabbit hole of trying to overengineer things. And the last learning number four, start backlogging things that are not a critical necessity very ruthlessly and very early. Do not spend time building out features that are a nice to have. The point of this exercise is to go through and build out an MVP quickly. So, what I mean by that is before you go in and start actually building out all of these different features that we got from those earlier steps, pop open each of these folders, look at each of the epics that are inside of it. Look at all of the stories that are inside of that epic and really ask yourself if what that thing is actually needs to be there in the MVP or if it can be pushed into the backlog. And if the answer is that it can be pushed into the backlog and it's a nice to have, it's not a critical path, then just do that and save yourself the headaches of moving slowly through each of these features as you're building things. All right, guys. Like I said, I' I'd keep hopping back in with anything relevant. Now, one thing that I've found really helps make sure that this thing actually builds out based on your designs that you gave is that when we run the plan and the tasks from spec kit, passing in secondary instructions that tell the system that that is in fact what it needs to do. And so we're telling it, hey, you need to actually build a pixel perfect UX replication based on any of the images that are in these directories. And now I found now that I've been doing this that pretty much everything I am getting out is matching much more closely with the actual UI like what we are intending for things to look like. It's on brand sometimes. I mean things are still a little bit off but it is much closer to what we actually wanted. So helpful little tip there. Um and I'll have a this will all be in the in the description below so you can just go and grab it. All right, guys. So, let's see how close we actually got to doing this. So, here's our main screen where we have, you know, our header, which we changed a little bit of the copy. Overall, this is like pretty close. There's obviously very small details we would need to tweak, but pretty close. So, then we can hit that begin button, and we come to this screen right here. So, again, this is pretty close. There's some things we can do with the contrast, right? So, like making making this match a little bit better, but again, pretty close overall. Also, we could come through here and we could put in like an actual problem, right? So, we could type in something like that. Then go to continue. Okay. Again, pretty good match to uh this page that we had here with some small adjustments and like copy and things like that. I do want to have this little blur out where you can see what's meant to be under the hood. Um so, I would go back through and do that, but I'm just going to pick one of these. Go to continue. Okay. Then it pumps us into a chat. So, I did away with the whole progress bar thing um in this implementation, but we might come back and actually add that in. And so, now we can move through and actually answer these questions. So, um I'll go through and answer some of these and show you what that chat looks like. Okay, so we send messages through and then we get that nice little uh kind of bubble here. This like create summary button, this is temporary. I'm going to end up moving this down into like a command pallet over here. So, don't worry about that from right now. But, it's going to go through now. It's actually using prompts, which I'll show you in a second, to determine what the language model is going to reply. So, this is all actual like live data. It's not dummy data. There's a backend hooked into it. All just by looping through that spec kit process that we've been going through. Now, again, there's some tiny things that we're going to need to mess around with as far as the styling goes. Like the overall like color contrast in this screen obviously isn't matching this the way it needs to. But again, easy details that we can come back and update later. So after enough messages go by, it moves into this workflow where it's going to generate insights for us. Okay. Um this needs to be dialed in a little bit, but it actually goes through and has the language model reframe the person's problem, which again we have prompts for all of that and it will pull out key insight. So in this example that we are moving through the user equates self-worth and success primarily with financial achievement which may limit their exploration of fulfilling career avenues. Right? So it's going through and this would all get a lot better as we take time to really think through like how would we want to actually prompt um for stuff like that. All right. So then I had to make a little home screen because we didn't have like a a home screen in our initial designs. But what I just did was use again use Stitch to spin up like what would a home screen actually look like? And I liked the idea of this one, so I used that to adapt and create this one that we're looking at right here. Okay. Then we move on to this like trophy room, which I renamed to the Insight Vault. But we can look, I mean, pretty close. Obviously, the icons and things like that, we'd have to go find versions of icons that are going to that are going to work for us, but pretty close um as far as like meeting the design where it was. So, we have this nice um little container with this nice little shadow on it. Um, again, pretty pretty close when all is said and done. There's some small things that we could dial in, but looking uh looking pretty good. And again, the big thing is that this is all hooked up to an actual backend. So, if we were to click into review one of these insights, which was meant to be of like a clone of of this, where we can look at like what was the thread of the conversation and the major mile markers along the way, we can see what that looks like. And this is all again being generated from the back end. where it actually understands what the challenge was, what the main prompt was, what the turning point in the conversation was, the main insight that the user reached, uh, all of this stuff. And again, we need to change up some of the, um, some of the styling there so that it matches more closely what we had, but overall pretty nice. All right, guys. So, we got through feature one, two, and three in about like five by the time it is now, like five or six hours from the time that we started. And again, a lot of that was eaten up by a bug in this onboarding demo phase. So, a lot of this other stuff from here is just like nicer to have things. They aren't like primary blockers of getting an MVP of this thing into people's hands. The only things we would really need to do is put actual user authentication in place and actually put this into a hosted database if we wanted people to start being able to really use it in the wild. And again, the seed that started all of this was these screens that we have right here, which again, if you missed that video and you want to see it, I I will link it around here somewhere. But I think a real key to understand here is that something that seems relatively simple like that did can actually be surprisingly complicated once you get into the process of actually building things. And that's why I love this approach with the speckit because we got pretty far and built a lot of complex APIs and backends and all of that stuff just from these screenshots. And so if we were to go through and look really quick just just based on those first three like features that we moved through, how much did we actually create? So we created our root app layout where the authentication would be integrated the main tab navigation inside of our app that entire journal logic that we had and we were showing off all of the different settings which we didn't look at that are that are there. We created a bunch of different components that actually make this whole thing work from you know the the home screen through to all of the details of how the journal page actually works, right? Like very involved. All of this is hooked up properly to the front-end state as well as the backend, right? So, a lot of heavy lifting was done. An entire logic for how people out when they're outside of that demo phase can actually go back in and start up an entirely new conversation. So, if I went back home and wanted to start a new conversation, what does that process look like? Is all hooked up again with backend APIs, integrated with language models, integrated with the databases, all of that type of stuff. entire design system hooks for state management services to actually manage the the API and how we're sending requests to the backend and where it pulls that data from and how it all gets handled how the session gets handled how we're tracking events so that down the road if we want to be able to observe what's happening in the app and take action based on that feedback we know what's happening our error surfacing a bunch like what's actually going on and that was all just for the front end then we have the entire thing also done for our backend. We have an entire V1 API where the conversations are handled, the overall health of the app, how the journal is being handled, how the problems are being parsed, and we're making recommendations to users, the database connection, the logging, the different data models for the backend, the services that actually house the business logic of how all of this stuff is done, right? just like so much stuff that was realistically done in that time frame just to make these simple app screens come to life. And so one of the reasons I wanted to show you like exactly the scope of what was made, right? Because those are all like very big files all connected to one another. This is a reason that spec driven development with this type of process where we break it down into features and epics and stories can be super valuable because it it knows that the front end and the back end have to be connected together and it does it in a really intelligent nice way which obviously results in us having something that works. So remember guys, the real value in this system if you really want to build things that work is slowing down and chunking the work down into manageable pieces. And the best way to do that is to adopt some semblance of a realworld product team development process. Now, if you want to see how we can take these designs that we have, which are live, and really amp them up to the next level, I will link a video somewhere around here that walks through how we can actually improve our UI. As always, if you want to build stuff like this with a community of people that are trying to do the same thing, join the free group in the description below and make sure to subscribe so you get more videos like this. But that is it for this video. I'll see you in the next one.